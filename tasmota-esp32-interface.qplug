-- Tasmota ESP32 Interface Plugin for Q-SYS
-- Comprehensive interface for Tasmota devices on ESP32 hardware
-- Supports HTTP/REST and MQTT communication protocols

PluginInfo = {
  Name = "Tasmota ESP32 Interface",
  Version = "1.0.0",
  Id = "qsysc.tasmota.esp32.interface.1.0.0",
  Description = "Complete interface for Tasmota ESP32 devices supporting HTTP/REST and MQTT protocols",
  Author = "Q-SYS Community",
  ShowDebug = true
}

function GetColor(props)
  return {87, 155, 252}
end

function GetPrettyName(props)
  return "Tasmota ESP32 v" .. PluginInfo.Version
end

-- Properties
function GetProperties()
  local props = {
    {
      Name = "Debug Print",
      Type = "enum",
      Choices = {"None", "Tx/Rx", "Tx", "Rx", "Function Calls", "All"},
      Value = "All"
    },
    {
      Name = "Auto Connect",
      Type = "boolean",
      Value = true
    },
    {
      Name = "Parse JSON",
      Type = "boolean",
      Value = true
    },
    {
      Name = "Connection Timeout",
      Type = "integer",
      Min = 5,
      Max = 60,
      Value = 10
    },
    {
      Name = "Retry Attempts",
      Type = "integer",
      Min = 0,
      Max = 10,
      Value = 3
    },
    {
      Name = "Default Protocol",
      Type = "enum",
      Choices = {"HTTP", "MQTT"},
      Value = "HTTP"
    },
    {
      Name = "Power Relay Count",
      Type = "integer",
      Min = 0,
      Max = 8,
      Value = 8
    },
    {
      Name = "GPIO Output Count",
      Type = "integer",
      Min = 0,
      Max = 8,
      Value = 8
    },
    {
      Name = "GPIO Input Count",
      Type = "integer",
      Min = 0,
      Max = 8,
      Value = 8
    },
    {
      Name = "PWM Count",
      Type = "integer",
      Min = 0,
      Max = 4,
      Value = 4
    },
    {
      Name = "Analog Input Count",
      Type = "integer",
      Min = 0,
      Max = 4,
      Value = 4
    },
    {
      Name = "Temperature Sensor Count",
      Type = "integer",
      Min = 0,
      Max = 4,
      Value = 4
    },
    {
      Name = "Humidity Sensor Count",
      Type = "integer",
      Min = 0,
      Max = 4,
      Value = 4
    },
    {
      Name = "Pressure Sensor Count",
      Type = "integer",
      Min = 0,
      Max = 2,
      Value = 2
    }
  }
  return props
end

function RectifyProperties(props)
  return props
end

-- Define Controls
function GetControls(props)
  local ctls = {
    -- Connection Controls
    {
      Name = "protocol",
      ControlType = "Indicator",
      IndicatorType = "Text",
      PinStyle = "Output",
      UserPin = true
    },
    {
      Name = "protocol_http",
      ControlType = "Button",
      ButtonType = "Momentary",
      PinStyle = "Input",
      UserPin = true,
      Count = 1
    },
    {
      Name = "protocol_mqtt",
      ControlType = "Button",
      ButtonType = "Momentary",
      PinStyle = "Input",
      UserPin = true,
      Count = 1
    },
    {
      Name = "host",
      ControlType = "Text",
      PinStyle = "Both",
      UserPin = true
    },
    {
      Name = "port",
      ControlType = "Text",
      PinStyle = "Both",
      UserPin = true
    },
    {
      Name = "username",
      ControlType = "Text",
      PinStyle = "Both",
      UserPin = true
    },
    {
      Name = "password",
      ControlType = "Text",
      PinStyle = "Both",
      UserPin = true
    },
    {
      Name = "mqtt_topic",
      ControlType = "Text",
      PinStyle = "Both",
      UserPin = true
    },
    {
      Name = "connect",
      ControlType = "Button",
      ButtonType = "Toggle",
      PinStyle = "Both",
      UserPin = true,
      Count = 1
    },
    {
      Name = "connection_status",
      ControlType = "Indicator",
      IndicatorType = "Status",
      PinStyle = "Output",
      UserPin = true,
      Count = 1
    },
    {
      Name = "connection_state",
      ControlType = "Indicator",
      IndicatorType = "Text",
      PinStyle = "Output",
      UserPin = true,
      Count = 1
    },
    {
      Name = "poll_interval",
      ControlType = "Knob",
      ControlUnit = "Integer",
      Min = 1,
      Max = 60,
      PinStyle = "Both",
      UserPin = true,
      Count = 1
    },
    
    -- Power/Relay Controls (configurable count)
    {
      Name = "power",
      ControlType = "Button",
      ButtonType = "Toggle",
      PinStyle = "Both",
      UserPin = true,
      Count = props["Power Relay Count"].Value
    },
    {
      Name = "power_status",
      ControlType = "Indicator",
      IndicatorType = "Led",
      PinStyle = "Output",
      UserPin = true,
      Count = props["Power Relay Count"].Value
    },
    {
      Name = "pulse_time",
      ControlType = "Text",
      PinStyle = "Both",
      UserPin = true,
      Count = props["Power Relay Count"].Value
    },
    {
      Name = "power_on_state",
      ControlType = "Text",
      PinStyle = "Both",
      UserPin = true,
      Count = props["Power Relay Count"].Value
    },
    
    -- Sensor Displays (configurable counts)
    {
      Name = "temperature",
      ControlType = "Indicator",
      IndicatorType = "Text",
      PinStyle = "Output",
      UserPin = true,
      Count = props["Temperature Sensor Count"].Value
    },
    {
      Name = "humidity",
      ControlType = "Indicator",
      IndicatorType = "Text",
      PinStyle = "Output",
      UserPin = true,
      Count = props["Humidity Sensor Count"].Value
    },
    {
      Name = "pressure",
      ControlType = "Indicator",
      IndicatorType = "Text",
      PinStyle = "Output",
      UserPin = true,
      Count = props["Pressure Sensor Count"].Value
    },
    {
      Name = "voltage",
      ControlType = "Indicator",
      IndicatorType = "Text",
      PinStyle = "Output",
      UserPin = true,
      Count = 1
    },
    {
      Name = "current",
      ControlType = "Indicator",
      IndicatorType = "Text",
      PinStyle = "Output",
      UserPin = true,
      Count = 1
    },
    {
      Name = "power_watts",
      ControlType = "Indicator",
      IndicatorType = "Text",
      PinStyle = "Output",
      UserPin = true,
      Count = 1
    },
    {
      Name = "energy_kwh",
      ControlType = "Indicator",
      IndicatorType = "Text",
      PinStyle = "Output",
      UserPin = true,
      Count = 1
    },
    
    -- Light Controls
    {
      Name = "dimmer",
      ControlType = "Knob",
      ControlUnit = "Integer",
      Min = 0,
      Max = 100,
      PinStyle = "Both",
      UserPin = true,
      Count = 1
    },
    {
      Name = "color_r",
      ControlType = "Knob",
      ControlUnit = "Integer",
      Min = 0,
      Max = 255,
      PinStyle = "Both",
      UserPin = true,
      Count = 1
    },
    {
      Name = "color_g",
      ControlType = "Knob",
      ControlUnit = "Integer",
      Min = 0,
      Max = 255,
      PinStyle = "Both",
      UserPin = true,
      Count = 1
    },
    {
      Name = "color_b",
      ControlType = "Knob",
      ControlUnit = "Integer",
      Min = 0,
      Max = 255,
      PinStyle = "Both",
      UserPin = true,
      Count = 1
    },
    {
      Name = "color_w",
      ControlType = "Knob",
      ControlUnit = "Integer",
      Min = 0,
      Max = 255,
      PinStyle = "Both",
      UserPin = true,
      Count = 1
    },
    {
      Name = "color_temp",
      ControlType = "Knob",
      ControlUnit = "Integer",
      Min = 153,
      Max = 500,
      PinStyle = "Both",
      UserPin = true,
      Count = 1
    },
    {
      Name = "hsb_h",
      ControlType = "Knob",
      ControlUnit = "Integer",
      Min = 0,
      Max = 360,
      PinStyle = "Both",
      UserPin = true,
      Count = 1
    },
    {
      Name = "hsb_s",
      ControlType = "Knob",
      ControlUnit = "Integer",
      Min = 0,
      Max = 100,
      PinStyle = "Both",
      UserPin = true,
      Count = 1
    },
    {
      Name = "hsb_b",
      ControlType = "Knob",
      ControlUnit = "Integer",
      Min = 0,
      Max = 100,
      PinStyle = "Both",
      UserPin = true,
      Count = 1
    },
    {
      Name = "scheme",
      ControlType = "Text",
      PinStyle = "Both",
      UserPin = true
    },
    {
      Name = "fade_speed",
      ControlType = "Knob",
      ControlUnit = "Integer",
      Min = 0,
      Max = 20,
      PinStyle = "Both",
      UserPin = true,
      Count = 1
    },
    
    -- GPIO Controls (configurable counts)
    {
      Name = "gpio_out",
      ControlType = "Button",
      ButtonType = "Toggle",
      PinStyle = "Both",
      UserPin = true,
      Count = props["GPIO Output Count"].Value
    },
    {
      Name = "gpio_in",
      ControlType = "Indicator",
      IndicatorType = "Led",
      PinStyle = "Output",
      UserPin = true,
      Count = props["GPIO Input Count"].Value
    },
    {
      Name = "pwm",
      ControlType = "Knob",
      ControlUnit = "Integer",
      Min = 0,
      Max = 1023,
      PinStyle = "Both",
      UserPin = true,
      Count = props["PWM Count"].Value
    },
    {
      Name = "analog_in",
      ControlType = "Indicator",
      IndicatorType = "Text",
      PinStyle = "Output",
      UserPin = true,
      Count = props["Analog Input Count"].Value
    },
    
    -- Custom Command Interface
    {
      Name = "custom_command",
      ControlType = "Text",
      PinStyle = "Both",
      UserPin = true
    },
    {
      Name = "send_command",
      ControlType = "Button",
      ButtonType = "Trigger",
      PinStyle = "Input",
      UserPin = true,
      Count = 1
    },
    {
      Name = "command_response",
      ControlType = "Indicator",
      IndicatorType = "Text",
      PinStyle = "Output",
      UserPin = true,
      Count = 1
    },
    
    -- Status & Info
    {
      Name = "device_name",
      ControlType = "Indicator",
      IndicatorType = "Text",
      PinStyle = "Output",
      UserPin = true,
      Count = 1
    },
    {
      Name = "friendly_name",
      ControlType = "Indicator",
      IndicatorType = "Text",
      PinStyle = "Output",
      UserPin = true,
      Count = props["Power Relay Count"].Value
    },
    {
      Name = "wifi_rssi",
      ControlType = "Indicator",
      IndicatorType = "Text",
      PinStyle = "Output",
      UserPin = true,
      Count = 1
    },
    {
      Name = "uptime",
      ControlType = "Indicator",
      IndicatorType = "Text",
      PinStyle = "Output",
      UserPin = true,
      Count = 1
    },
    {
      Name = "ip_address",
      ControlType = "Indicator",
      IndicatorType = "Text",
      PinStyle = "Output",
      UserPin = true,
      Count = 1
    },
    {
      Name = "firmware_version",
      ControlType = "Indicator",
      IndicatorType = "Text",
      PinStyle = "Output",
      UserPin = true,
      Count = 1
    },
    {
      Name = "heap_memory",
      ControlType = "Indicator",
      IndicatorType = "Text",
      PinStyle = "Output",
      UserPin = true,
      Count = 1
    }
  }
  return ctls
end


-- Define Pages
function GetPages(props)
  local pages = {
    {name = "Connection"},
    {name = "Power & Relays"},
    {name = "Sensors"},
    {name = "Lighting"},
    {name = "GPIO & Advanced"},
    {name = "Status & Info"}
  }
  return pages
end

function GetComponents(props)
  return {}
end

-- Define Layout
function GetControlLayout(props)
  local layout = {}
  local graphics = {}
  
  local CurrentPage = props["page_index"].Value
  
  -- PAGE 1: Connection
  if CurrentPage == 1 then
    
    table.insert(graphics, {
      Type = "GroupBox",
      Text = "Connection Settings",
      Fill = {87, 155, 252},
      CornerRadius = 12,
      StrokeColor = {0, 0, 0},
      StrokeWidth = 1,
      Position = {5, 5},
      Size = {490, 380}
    })
    
    -- Protocol Selection
    table.insert(graphics, {
      Type = "Label",
      Text = "Protocol:",
      Position = {15, 35},
      Size = {80, 20},
      FontSize = 12,
      HTextAlign = "Right"
    })
    
    layout["protocol"] = {
      PrettyName = "Current Protocol",
      Position = {105, 32},
      Size = {100, 25},
      FontSize = 12
    }
    
    layout["protocol_http"] = {
      PrettyName = "HTTP",
      Position = {215, 30},
      Size = {80, 28},
      Legend = "HTTP"
    }
    
    layout["protocol_mqtt"] = {
      PrettyName = "MQTT",
      Position = {305, 30},
      Size = {80, 28},
      Legend = "MQTT"
    }
    
    -- Host/IP
    table.insert(graphics, {
      Type = "Label",
      Text = "Host/IP:",
      Position = {15, 75},
      Size = {80, 20},
      FontSize = 12,
      HTextAlign = "Right"
    })
    
    layout["host"] = {
      PrettyName = "Host/IP Address",
      Style = "Text",
      Position = {105, 72},
      Size = {200, 25},
      FontSize = 12,
      Color = {255, 255, 255}
    }
    
    -- Port
    table.insert(graphics, {
      Type = "Label",
      Text = "Port:",
      Position = {315, 75},
      Size = {40, 20},
      FontSize = 12,
      HTextAlign = "Right"
    })
    
    layout["port"] = {
      PrettyName = "Port",
      Style = "Text",
      Position = {365, 72},
      Size = {120, 25},
      FontSize = 12,
      Color = {255, 255, 255}
    }
    
    -- Username
    table.insert(graphics, {
      Type = "Label",
      Text = "Username:",
      Position = {15, 110},
      Size = {80, 20},
      FontSize = 12,
      HTextAlign = "Right"
    })
    
    layout["username"] = {
      PrettyName = "Username",
      Style = "Text",
      Position = {105, 107},
      Size = {380, 25},
      FontSize = 12,
      Color = {255, 255, 255}
    }
    
    -- Password
    table.insert(graphics, {
      Type = "Label",
      Text = "Password:",
      Position = {15, 145},
      Size = {80, 20},
      FontSize = 12,
      HTextAlign = "Right"
    })
    
    layout["password"] = {
      PrettyName = "Password",
      Style = "Text",
      Position = {105, 142},
      Size = {380, 25},
      FontSize = 12,
      Color = {255, 255, 255}
    }
    
    -- MQTT Topic
    table.insert(graphics, {
      Type = "Label",
      Text = "MQTT Topic:",
      Position = {15, 180},
      Size = {80, 20},
      FontSize = 12,
      HTextAlign = "Right"
    })
    
    layout["mqtt_topic"] = {
      PrettyName = "MQTT Topic (for MQTT mode)",
      Style = "Text",
      Position = {105, 177},
      Size = {380, 25},
      FontSize = 12,
      Color = {255, 255, 255}
    }
    
    -- Poll Interval
    table.insert(graphics, {
      Type = "Label",
      Text = "Poll Interval (s):",
      Position = {15, 220},
      Size = {80, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["poll_interval"] = {
      PrettyName = "HTTP Poll Interval",
      Position = {105, 212},
      Size = {100, 36},
      FontSize = 12
    }
    
    -- Connection Status
    table.insert(graphics, {
      Type = "Label",
      Text = "Status:",
      Position = {15, 265},
      Size = {80, 20},
      FontSize = 12,
      HTextAlign = "Right"
    })
    
    layout["connection_status"] = {
      PrettyName = "Connection Status",
      Position = {105, 260},
      Size = {40, 30}
    }
    
    layout["connection_state"] = {
      PrettyName = "Connection State",
      Position = {155, 262},
      Size = {330, 26},
      FontSize = 11
    }
    
    -- Connect Button
    layout["connect"] = {
      PrettyName = "Connect/Disconnect",
      Position = {105, 310},
      Size = {380, 60},
      Legend = "Connect"
    }
    
  -- PAGE 2: Power & Relays
  elseif CurrentPage == 2 then
    
    local relay_count = props["Power Relay Count"].Value
    
    if relay_count == 0 then
      -- No relays configured - show minimal informational message
      table.insert(graphics, {
        Type = "GroupBox",
        Text = "No Relays Configured",
        Fill = {100, 100, 100},
        CornerRadius = 12,
        StrokeColor = {0, 0, 0},
        StrokeWidth = 1,
        Position = {5, 5},
        Size = {490, 100}
      })
      
      table.insert(graphics, {
        Type = "Label",
        Text = "Set 'Power Relay Count' in Properties to add relay controls",
        Position = {20, 35},
        Size = {450, 40},
        FontSize = 12,
        HTextAlign = "Center"
      })
    else
      -- Calculate dynamic height based on relay count
      local groupbox_height = 30 + (relay_count * 55)
      
      table.insert(graphics, {
        Type = "GroupBox",
        Text = "Power Controls (Relays 1-" .. relay_count .. ")",
        Fill = {100, 180, 100},
        CornerRadius = 12,
        StrokeColor = {0, 0, 0},
        StrokeWidth = 1,
        Position = {5, 5},
        Size = {490, groupbox_height}
      })
      
      -- Initialize layout arrays for power controls
      layout["power"] = {}
      layout["power_status"] = {}
      layout["pulse_time"] = {}
      layout["power_on_state"] = {}
      
      for i = 1, relay_count do
        local yPos = 30 + ((i-1) * 55)
        
        -- Relay Label
        table.insert(graphics, {
          Type = "Label",
          Text = "Relay " .. i .. ":",
          Position = {15, yPos + 10},
          Size = {60, 20},
          FontSize = 11,
          HTextAlign = "Right"
        })
        
        -- Power Toggle
        layout["power"][i] = {
          PrettyName = "Power " .. i,
          Position = {85, yPos + 5},
          Size = {80, 30},
          Legend = "Power " .. i
        }
        
        -- Status LED
        layout["power_status"][i] = {
          PrettyName = "Power " .. i .. " Status",
          Position = {175, yPos + 10},
          Size = {20, 20}
        }
        
        -- Pulse Time
        table.insert(graphics, {
          Type = "Label",
          Text = "Pulse:",
          Position = {205, yPos + 10},
          Size = {45, 20},
          FontSize = 10,
          HTextAlign = "Right"
        })
        
        layout["pulse_time"][i] = {
          PrettyName = "Pulse Time " .. i,
          Style = "Text",
          Position = {255, yPos + 7},
          Size = {80, 26},
          FontSize = 10,
          Color = {255, 255, 255}
        }
        
        -- Power On State
        table.insert(graphics, {
          Type = "Label",
          Text = "On State:",
          Position = {345, yPos + 10},
          Size = {55, 20},
          FontSize = 10,
          HTextAlign = "Right"
        })
        
        layout["power_on_state"][i] = {
          PrettyName = "Power On State " .. i,
          Style = "Text",
          Position = {405, yPos + 7},
          Size = {75, 26},
          FontSize = 10,
          Color = {255, 255, 255}
        }
      end
    end
    
  -- PAGE 3: Sensors
  elseif CurrentPage == 3 then
    
    local temp_count = props["Temperature Sensor Count"].Value
    local hum_count = props["Humidity Sensor Count"].Value
    local press_count = props["Pressure Sensor Count"].Value
    
    -- Temperature Sensors GroupBox
    local temp_height = temp_count > 0 and (30 + temp_count * 30) or 60
    table.insert(graphics, {
      Type = "GroupBox",
      Text = "Temperature Sensors" .. (temp_count > 0 and "" or " (None Configured)"),
      Fill = {200, 100, 100},
      CornerRadius = 8,
      StrokeColor = {0, 0, 0},
      StrokeWidth = 1,
      Position = {5, 5},
      Size = {240, temp_height}
    })
    
    if temp_count > 0 then
      layout["temperature"] = {}
      for i = 1, temp_count do
        local yPos = 25 + ((i-1) * 30)
        
        table.insert(graphics, {
          Type = "Label",
          Text = "Temp " .. i .. ":",
          Position = {15, yPos},
          Size = {60, 20},
          FontSize = 11,
          HTextAlign = "Right"
        })
        
        layout["temperature"][i] = {
          PrettyName = "Temperature " .. i,
          Position = {80, yPos - 2},
          Size = {150, 24},
          FontSize = 12
        }
      end
    else
      table.insert(graphics, {
        Type = "Label",
        Text = "Set 'Temperature Sensor Count' in Properties",
        Position = {15, 30},
        Size = {210, 20},
        FontSize = 10,
        HTextAlign = "Center"
      })
    end
    
    -- Humidity Sensors GroupBox
    local hum_height = hum_count > 0 and (30 + hum_count * 30) or 60
    table.insert(graphics, {
      Type = "GroupBox",
      Text = "Humidity Sensors" .. (hum_count > 0 and "" or " (None Configured)"),
      Fill = {100, 150, 200},
      CornerRadius = 8,
      StrokeColor = {0, 0, 0},
      StrokeWidth = 1,
      Position = {255, 5},
      Size = {240, hum_height}
    })
    
    if hum_count > 0 then
      layout["humidity"] = {}
      for i = 1, hum_count do
        local yPos = 25 + ((i-1) * 30)
        
        table.insert(graphics, {
          Type = "Label",
          Text = "Hum " .. i .. ":",
          Position = {265, yPos},
          Size = {60, 20},
          FontSize = 11,
          HTextAlign = "Right"
        })
        
        layout["humidity"][i] = {
          PrettyName = "Humidity " .. i,
          Position = {330, yPos - 2},
          Size = {150, 24},
          FontSize = 12
        }
      end
    else
      table.insert(graphics, {
        Type = "Label",
        Text = "Set 'Humidity Sensor Count' in Properties",
        Position = {265, 30},
        Size = {210, 20},
        FontSize = 10,
        HTextAlign = "Center"
      })
    end
    
    -- Pressure Sensors GroupBox
    local press_height = press_count > 0 and (30 + press_count * 30) or 60
    table.insert(graphics, {
      Type = "GroupBox",
      Text = "Pressure Sensors" .. (press_count > 0 and "" or " (None Configured)"),
      Fill = {150, 150, 150},
      CornerRadius = 8,
      StrokeColor = {0, 0, 0},
      StrokeWidth = 1,
      Position = {5, 155},
      Size = {240, press_height}
    })
    
    if press_count > 0 then
      layout["pressure"] = {}
      for i = 1, press_count do
        local yPos = 175 + ((i-1) * 30)
        
        table.insert(graphics, {
          Type = "Label",
          Text = "Press " .. i .. ":",
          Position = {15, yPos},
          Size = {60, 20},
          FontSize = 11,
          HTextAlign = "Right"
        })
        
        layout["pressure"][i] = {
          PrettyName = "Pressure " .. i,
          Position = {80, yPos - 2},
          Size = {150, 24},
          FontSize = 12
        }
      end
    else
      table.insert(graphics, {
        Type = "Label",
        Text = "Set 'Pressure Sensor Count' in Properties",
        Position = {15, 180},
        Size = {210, 20},
        FontSize = 10,
        HTextAlign = "Center"
      })
    end
    
    table.insert(graphics, {
      Type = "GroupBox",
      Text = "Power Monitoring",
      Fill = {200, 150, 50},
      CornerRadius = 8,
      StrokeColor = {0, 0, 0},
      StrokeWidth = 1,
      Position = {255, 155},
      Size = {240, 140}
    })
    
    table.insert(graphics, {
      Type = "Label",
      Text = "Voltage:",
      Position = {265, 175},
      Size = {60, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["voltage"] = {
      PrettyName = "Voltage",
      Position = {330, 173},
      Size = {150, 24},
      FontSize = 12
    }
    
    table.insert(graphics, {
      Type = "Label",
      Text = "Current:",
      Position = {265, 205},
      Size = {60, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["current"] = {
      PrettyName = "Current",
      Position = {330, 203},
      Size = {150, 24},
      FontSize = 12
    }
    
    table.insert(graphics, {
      Type = "Label",
      Text = "Power:",
      Position = {265, 235},
      Size = {60, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["power_watts"] = {
      PrettyName = "Power (Watts)",
      Position = {330, 233},
      Size = {150, 24},
      FontSize = 12
    }
    
    table.insert(graphics, {
      Type = "Label",
      Text = "Energy:",
      Position = {265, 265},
      Size = {60, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["energy_kwh"] = {
      PrettyName = "Energy (kWh)",
      Position = {330, 263},
      Size = {150, 24},
      FontSize = 12
    }
    
  -- PAGE 4: Lighting
  elseif CurrentPage == 4 then
    
    table.insert(graphics, {
      Type = "GroupBox",
      Text = "Dimmer Control",
      Fill = {255, 200, 100},
      CornerRadius = 8,
      StrokeColor = {0, 0, 0},
      StrokeWidth = 1,
      Position = {5, 5},
      Size = {240, 100}
    })
    
    table.insert(graphics, {
      Type = "Label",
      Text = "Brightness:",
      Position = {15, 30},
      Size = {80, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["dimmer"] = {
      PrettyName = "Dimmer (0-100%)",
      Position = {105, 22},
      Size = {120, 56},
      FontSize = 14
    }
    
    table.insert(graphics, {
      Type = "GroupBox",
      Text = "RGB/RGBW Color Control",
      Fill = {180, 100, 180},
      CornerRadius = 8,
      StrokeColor = {0, 0, 0},
      StrokeWidth = 1,
      Position = {255, 5},
      Size = {240, 200}
    })
    
    table.insert(graphics, {
      Type = "Label",
      Text = "Red:",
      Position = {265, 30},
      Size = {40, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["color_r"] = {
      PrettyName = "Red (0-255)",
      Position = {315, 22},
      Size = {70, 45},
      FontSize = 11
    }
    
    table.insert(graphics, {
      Type = "Label",
      Text = "Green:",
      Position = {265, 80},
      Size = {40, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["color_g"] = {
      PrettyName = "Green (0-255)",
      Position = {315, 72},
      Size = {70, 45},
      FontSize = 11
    }
    
    table.insert(graphics, {
      Type = "Label",
      Text = "Blue:",
      Position = {265, 130},
      Size = {40, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["color_b"] = {
      PrettyName = "Blue (0-255)",
      Position = {315, 122},
      Size = {70, 45},
      FontSize = 11
    }
    
    table.insert(graphics, {
      Type = "Label",
      Text = "White:",
      Position = {400, 80},
      Size = {40, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["color_w"] = {
      PrettyName = "White (0-255)",
      Position = {405, 22},
      Size = {70, 45},
      FontSize = 11
    }
    
    table.insert(graphics, {
      Type = "GroupBox",
      Text = "Color Temperature",
      Fill = {255, 180, 120},
      CornerRadius = 8,
      StrokeColor = {0, 0, 0},
      StrokeWidth = 1,
      Position = {5, 115},
      Size = {240, 90}
    })
    
    table.insert(graphics, {
      Type = "Label",
      Text = "CT (mireds):",
      Position = {15, 140},
      Size = {80, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["color_temp"] = {
      PrettyName = "Color Temp (153-500 mireds)",
      Position = {105, 132},
      Size = {120, 56},
      FontSize = 12
    }
    
    table.insert(graphics, {
      Type = "GroupBox",
      Text = "HSB Control",
      Fill = {120, 200, 180},
      CornerRadius = 8,
      StrokeColor = {0, 0, 0},
      StrokeWidth = 1,
      Position = {5, 215},
      Size = {240, 150}
    })
    
    table.insert(graphics, {
      Type = "Label",
      Text = "Hue (0-360):",
      Position = {15, 235},
      Size = {80, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["hsb_h"] = {
      PrettyName = "Hue",
      Position = {105, 227},
      Size = {120, 45},
      FontSize = 11
    }
    
    table.insert(graphics, {
      Type = "Label",
      Text = "Sat (0-100):",
      Position = {15, 285},
      Size = {80, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["hsb_s"] = {
      PrettyName = "Saturation",
      Position = {105, 277},
      Size = {120, 45},
      FontSize = 11
    }
    
    table.insert(graphics, {
      Type = "Label",
      Text = "Bright (0-100):",
      Position = {15, 335},
      Size = {80, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["hsb_b"] = {
      PrettyName = "Brightness",
      Position = {105, 327},
      Size = {120, 45},
      FontSize = 11
    }
    
    table.insert(graphics, {
      Type = "GroupBox",
      Text = "Effects & Schemes",
      Fill = {150, 150, 200},
      CornerRadius = 8,
      StrokeColor = {0, 0, 0},
      StrokeWidth = 1,
      Position = {255, 215},
      Size = {240, 150}
    })
    
    table.insert(graphics, {
      Type = "Label",
      Text = "Scheme:",
      Position = {265, 240},
      Size = {80, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["scheme"] = {
      PrettyName = "Light Scheme",
      Style = "Text",
      Position = {355, 237},
      Size = {125, 26},
      FontSize = 11,
      Color = {255, 255, 255}
    }
    
    table.insert(graphics, {
      Type = "Label",
      Text = "Fade Speed:",
      Position = {265, 285},
      Size = {80, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["fade_speed"] = {
      PrettyName = "Fade Speed (0-20)",
      Position = {355, 277},
      Size = {120, 56},
      FontSize = 11
    }
    
  -- PAGE 5: GPIO & Advanced
  elseif CurrentPage == 5 then
    
    local gpio_out_count = props["GPIO Output Count"].Value
    local gpio_in_count = props["GPIO Input Count"].Value
    local pwm_count = props["PWM Count"].Value
    local analog_count = props["Analog Input Count"].Value
    
    -- GPIO Outputs GroupBox
    local gpio_height = gpio_out_count > 0 and (30 + gpio_out_count * 26) or 60
    table.insert(graphics, {
      Type = "GroupBox",
      Text = "GPIO Outputs" .. (gpio_out_count > 0 and " (1-" .. gpio_out_count .. ")" or " (None Configured)"),
      Fill = {120, 120, 180},
      CornerRadius = 8,
      StrokeColor = {0, 0, 0},
      StrokeWidth = 1,
      Position = {5, 5},
      Size = {240, gpio_height}
    })
    
    if gpio_out_count > 0 then
      layout["gpio_out"] = {}
      layout["gpio_in"] = {}
      
      for i = 1, gpio_out_count do
        local yPos = 25 + ((i-1) * 26)
        
        table.insert(graphics, {
          Type = "Label",
          Text = "GPIO " .. i .. ":",
          Position = {15, yPos},
          Size = {60, 20},
          FontSize = 10,
          HTextAlign = "Right"
        })
        
        layout["gpio_out"][i] = {
          PrettyName = "GPIO Output " .. i,
          Position = {80, yPos - 2},
          Size = {70, 24},
          Legend = "Out " .. i
        }
        
        if i <= gpio_in_count then
          layout["gpio_in"][i] = {
            PrettyName = "GPIO Input " .. i,
            Position = {160, yPos},
            Size = {20, 20}
          }
          
          table.insert(graphics, {
            Type = "Label",
            Text = "In",
            Position = {185, yPos},
            Size = {25, 20},
            FontSize = 9
          })
        end
      end
    else
      table.insert(graphics, {
        Type = "Label",
        Text = "Set 'GPIO Output Count' in Properties",
        Position = {15, 30},
        Size = {210, 20},
        FontSize = 10,
        HTextAlign = "Center"
      })
    end
    
    -- PWM Outputs GroupBox
    local pwm_height = pwm_count > 0 and (30 + math.ceil(pwm_count / 2) * 55) or 60
    table.insert(graphics, {
      Type = "GroupBox",
      Text = "PWM Outputs" .. (pwm_count > 0 and " (1-" .. pwm_count .. ")" or " (None Configured)"),
      Fill = {180, 150, 100},
      CornerRadius = 8,
      StrokeColor = {0, 0, 0},
      StrokeWidth = 1,
      Position = {255, 5},
      Size = {240, pwm_height}
    })
    
    if pwm_count > 0 then
      layout["pwm"] = {}
      
      for i = 1, pwm_count do
        local xPos = 265 + ((i-1) % 2) * 110
        local yPos = 25 + math.floor((i-1) / 2) * 55
        
        table.insert(graphics, {
          Type = "Label",
          Text = "PWM " .. i .. ":",
          Position = {xPos, yPos + 5},
          Size = {45, 20},
          FontSize = 10,
          HTextAlign = "Right"
        })
        
        layout["pwm"][i] = {
          PrettyName = "PWM " .. i .. " (0-1023)",
          Position = {xPos, yPos + 22},
          Size = {90, 42},
          FontSize = 11
        }
      end
    else
      table.insert(graphics, {
        Type = "Label",
        Text = "Set 'PWM Count' in Properties",
        Position = {265, 30},
        Size = {210, 20},
        FontSize = 10,
        HTextAlign = "Center"
      })
    end
    
    -- Analog Inputs GroupBox
    local analog_height = analog_count > 0 and (30 + math.ceil(analog_count / 2) * 28) or 60
    table.insert(graphics, {
      Type = "GroupBox",
      Text = "Analog Inputs" .. (analog_count > 0 and " (1-" .. analog_count .. ")" or " (None Configured)"),
      Fill = {100, 180, 150},
      CornerRadius = 8,
      StrokeColor = {0, 0, 0},
      StrokeWidth = 1,
      Position = {255, 135},
      Size = {240, analog_height}
    })
    
    if analog_count > 0 then
      layout["analog_in"] = {}
      
      for i = 1, analog_count do
        local yPos = 155 + ((i-1) % 2) * 28
        local xPos = 265 + math.floor((i-1) / 2) * 110
        
        table.insert(graphics, {
          Type = "Label",
          Text = "ADC" .. i .. ":",
          Position = {xPos, yPos},
          Size = {40, 20},
          FontSize = 10,
          HTextAlign = "Right"
        })
        
        layout["analog_in"][i] = {
          PrettyName = "Analog Input " .. i,
          Position = {xPos + 45, yPos - 2},
          Size = {55, 24},
          FontSize = 10
        }
      end
    else
      table.insert(graphics, {
        Type = "Label",
        Text = "Set 'Analog Input Count' in Properties",
        Position = {265, 160},
        Size = {210, 20},
        FontSize = 10,
        HTextAlign = "Center"
      })
    end
    
    table.insert(graphics, {
      Type = "GroupBox",
      Text = "Custom Command",
      Fill = {200, 120, 120},
      CornerRadius = 8,
      StrokeColor = {0, 0, 0},
      StrokeWidth = 1,
      Position = {5, 245},
      Size = {490, 120}
    })
    
    table.insert(graphics, {
      Type = "Label",
      Text = "Command:",
      Position = {15, 270},
      Size = {70, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["custom_command"] = {
      PrettyName = "Custom Command",
      Style = "Text",
      Position = {95, 267},
      Size = {300, 26},
      FontSize = 11,
      Color = {255, 255, 255}
    }
    
    layout["send_command"] = {
      PrettyName = "Send Command",
      Position = {405, 265},
      Size = {80, 30},
      Legend = "Send"
    }
    
    table.insert(graphics, {
      Type = "Label",
      Text = "Response:",
      Position = {15, 310},
      Size = {70, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["command_response"] = {
      PrettyName = "Command Response",
      Position = {95, 305},
      Size = {390, 50},
      FontSize = 10
    }
    
  -- PAGE 6: Status & Info
  elseif CurrentPage == 6 then
    
    table.insert(graphics, {
      Type = "GroupBox",
      Text = "Device Information",
      Fill = {150, 150, 150},
      CornerRadius = 8,
      StrokeColor = {0, 0, 0},
      StrokeWidth = 1,
      Position = {5, 5},
      Size = {490, 230}
    })
    
    table.insert(graphics, {
      Type = "Label",
      Text = "Device Name:",
      Position = {15, 30},
      Size = {100, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["device_name"] = {
      PrettyName = "Device Name",
      Position = {125, 27},
      Size = {355, 26},
      FontSize = 12
    }
    
    table.insert(graphics, {
      Type = "Label",
      Text = "IP Address:",
      Position = {15, 65},
      Size = {100, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["ip_address"] = {
      PrettyName = "IP Address",
      Position = {125, 62},
      Size = {170, 26},
      FontSize = 12
    }
    
    table.insert(graphics, {
      Type = "Label",
      Text = "WiFi RSSI:",
      Position = {310, 65},
      Size = {70, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["wifi_rssi"] = {
      PrettyName = "WiFi Signal Strength",
      Position = {390, 62},
      Size = {90, 26},
      FontSize = 12
    }
    
    table.insert(graphics, {
      Type = "Label",
      Text = "Firmware:",
      Position = {15, 100},
      Size = {100, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["firmware_version"] = {
      PrettyName = "Firmware Version",
      Position = {125, 97},
      Size = {355, 26},
      FontSize = 12
    }
    
    table.insert(graphics, {
      Type = "Label",
      Text = "Uptime:",
      Position = {15, 135},
      Size = {100, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["uptime"] = {
      PrettyName = "Uptime",
      Position = {125, 132},
      Size = {170, 26},
      FontSize = 12
    }
    
    table.insert(graphics, {
      Type = "Label",
      Text = "Heap Memory:",
      Position = {310, 135},
      Size = {70, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["heap_memory"] = {
      PrettyName = "Free Heap Memory",
      Position = {390, 132},
      Size = {90, 26},
      FontSize = 12
    }
    
    table.insert(graphics, {
      Type = "GroupBox",
      Text = "Friendly Names",
      Fill = {120, 180, 150},
      CornerRadius = 8,
      StrokeColor = {0, 0, 0},
      StrokeWidth = 1,
      Position = {5, 175},
      Size = {475, 56}
    })
    
    table.insert(graphics, {
      Type = "Label",
      Text = "Friendly Name:",
      Position = {15, 200},
      Size = {100, 20},
      FontSize = 11,
      HTextAlign = "Right"
    })
    
    layout["friendly_name"] = {}
    layout["friendly_name"][1] = {
      PrettyName = "Friendly Name 1",
      Position = {125, 197},
      Size = {345, 26},
      FontSize = 11
    }
    
  end
  
  return layout, graphics
end


-- Runtime Code
if Controls then
  
  -- State Variables
  local active_socket = nil
  local mqtt_socket = nil
  local http_socket = nil
  local current_protocol = Properties["Default Protocol"].Value
  local is_connected = false
  local packet_id = 1
  local keep_alive_timer = nil
  local poll_timer = nil
  local command_queue = {}
  local subscribed_topics = {}
  local pending_qos2 = {}
  local device_state = {}
  local http_buffer = ""
  local is_polling = false
  local http_poll_timer = nil
  
  -- JSON Library
  local rapidjson = require("rapidjson")
  
  -- Debug Print Function
  local function DebugPrint(category, message)
    local debug_mode = Properties["Debug Print"].Value
    local should_print = false
    
    if debug_mode == "All" then
      should_print = true
    elseif debug_mode == "Tx/Rx" and (category == "Tx" or category == "Rx") then
      should_print = true
    elseif debug_mode == "Tx" and category == "Tx" then
      should_print = true
    elseif debug_mode == "Rx" and category == "Rx" then
      should_print = true
    elseif debug_mode == "Function Calls" and category == "Function" then
      should_print = true
    end
    
    if should_print then
      print(string.format("[Tasmota %s] %s", category, message))
    end
  end
  
  -- Update Status
  local function UpdateStatus(state, message)
    Controls.connection_state.String = message
    DebugPrint("Status", string.format("%s: %s", state, message))
    
    if state == "Connected" then
      Controls.connection_status.Value = 0 -- OK
      Controls.connect.Boolean = true
      is_connected = true
    elseif state == "Disconnected" then
      Controls.connection_status.Value = 2 -- Compromised
      Controls.connect.Boolean = false
      is_connected = false
    elseif state == "Error" then
      Controls.connection_status.Value = 5 -- Fault
      Controls.connect.Boolean = false
      is_connected = false
    else
      Controls.connection_status.Value = 1 -- Initializing
    end
  end
  
  -- JSON Parsing Helper
  local function ParseJSON(json_string)
    if not Properties["Parse JSON"].Value then
      return json_string
    end
    
    local success, result = pcall(function()
      return rapidjson.decode(json_string)
    end)
    
    if success and type(result) == "table" then
      return result
    else
      return json_string
    end
  end
  
  -- JSON Stringify Helper
  local function StringifyJSON(obj)
    local success, result = pcall(function()
      return rapidjson.encode(obj)
    end)
    
    if success then
      return result
    else
      return tostring(obj)
    end
  end
  
  -- ========================================
  -- HTTP/REST API Implementation
  -- ========================================
  
  local function EncodeURL(str)
    if str then
      str = string.gsub(str, "\n", "\r\n")
      str = string.gsub(str, "([^%w %-%_%.%~])",
        function(c) return string.format("%%%02X", string.byte(c)) end)
      str = string.gsub(str, " ", "+")
    end
    return str
  end
  
  -- HTTP Connection Manager - Creates new socket for each poll request
  local function ConnectAndPollHTTP()
    if not is_polling then return end
    
    local host = Controls.host.String
    local port = tonumber(Controls.port.String) or 80
    
    if host == "" then
      UpdateStatus("Error", "No host specified")
      return
    end
    
    -- Create new socket for each request
    http_socket = TcpSocket.New()
    http_socket.ReadTimeout = Properties["Connection Timeout"].Value
    http_socket.WriteTimeout = Properties["Connection Timeout"].Value
    http_buffer = ""
    
    http_socket.Connected = function(sock)
      DebugPrint("Function", "HTTP Connected callback")
      is_connected = true
      UpdateStatus("Connected", "HTTP connected - polling every " .. Controls.poll_interval.Value .. "s")
      
      -- Send request
      local command = "Status 0"
      local path = "/cm?cmnd=" .. EncodeURL(command)
      local request = string.format("GET %s HTTP/1.1\r\n", path)
      request = request .. string.format("Host: %s\r\n", host)
      
      -- Add authentication if provided
      if Controls.username.String ~= "" and Controls.password.String ~= "" then
        local auth = Controls.username.String .. ":" .. Controls.password.String
        local base64_auth = Crypto.Base64Encode(auth)
        request = request .. string.format("Authorization: Basic %s\r\n", base64_auth)
      end
      
      request = request .. "Connection: close\r\n\r\n"
      
      DebugPrint("Tx", "Sending HTTP request:\n" .. request)
      sock:Write(request)
    end
    
    http_socket.Data = function(sock)
      local data = sock:ReadLine(TcpSocket.EOL.Any)
      while data do
        DebugPrint("Rx", "HTTP Data: " .. data)
        http_buffer = http_buffer .. data .. "\n"
        data = sock:ReadLine(TcpSocket.EOL.Any)
      end
    end
    
    http_socket.Closed = function(sock)
      DebugPrint("Function", "HTTP Closed callback")
      
      -- Process received data
      if http_buffer ~= "" then
        -- Extract body from HTTP response
        local body_start = http_buffer:find("\n\n")
        if not body_start then
          body_start = http_buffer:find("\r\n\r\n")
        end
        
        if body_start then
          local body = http_buffer:sub(body_start):gsub("^%s+", "")
          if body ~= "" then
            DebugPrint("Rx", "HTTP Body: " .. body)
            ParseTasmotaResponse("status", body)
          end
        end
        
        http_buffer = ""
      end
      
      -- DO NOT reconnect here! Timer will handle next poll
    end
    
    http_socket.Error = function(sock, err)
      DebugPrint("Function", "HTTP Error: " .. (err or "Unknown"))
      UpdateStatus("Error", "HTTP Error: " .. (err or "Unknown"))
    end
    
    http_socket.Timeout = function(sock)
      DebugPrint("Function", "HTTP Timeout")
      UpdateStatus("Error", "HTTP connection timeout")
    end
    
    -- DO NOT handle Reconnect event! Let the timer control polling
    
    DebugPrint("Tx", string.format("Connecting to %s:%d", host, port))
    http_socket:Connect(host, port)
  end
  
  -- Start HTTP Polling with Timer
  local function StartHTTPPolling()
    is_polling = true
    
    -- Get poll interval in seconds
    local interval = Controls.poll_interval.Value or 5
    
    -- Stop any existing timer
    if http_poll_timer then
      http_poll_timer:Stop()
    end
    
    -- Create polling timer
    http_poll_timer = Timer.New()
    http_poll_timer.EventHandler = function(timer)
      if is_polling then
        ConnectAndPollHTTP()
      end
    end
    
    -- Start timer (repeating)
    http_poll_timer:Start(interval)
    
    -- Do first poll immediately
    ConnectAndPollHTTP()
    
    DebugPrint("Function", string.format("HTTP polling started (every %d seconds)", interval))
  end
  
  -- Stop HTTP Polling
  local function StopHTTPPolling()
    is_polling = false
    
    if http_poll_timer then
      http_poll_timer:Stop()
      http_poll_timer = nil
    end
    
    if http_socket then
      http_socket:Disconnect()
      http_socket = nil
    end
    
    DebugPrint("Function", "HTTP polling stopped")
  end
  
  -- Legacy HTTPRequest function for custom commands
  local function HTTPRequest(method, path, body, callback)
    DebugPrint("Function", string.format("HTTPRequest: %s %s", method, path))
    
    local host = Controls.host.String
    local port = tonumber(Controls.port.String) or 80
    
    if host == "" then
      UpdateStatus("Error", "No host specified")
      return
    end
    
    -- Create new socket for this request
    local req_socket = TcpSocket.New()
    req_socket.ReadTimeout = Properties["Connection Timeout"].Value
    req_socket.WriteTimeout = Properties["Connection Timeout"].Value
    local req_buffer = ""
    
    req_socket.Connected = function(sock)
      DebugPrint("Function", "HTTP Request Connected callback")
      
      -- Build HTTP request
      local request = string.format("%s %s HTTP/1.1\r\n", method, path)
      request = request .. string.format("Host: %s\r\n", host)
      
      -- Add authentication if provided
      if Controls.username.String ~= "" and Controls.password.String ~= "" then
        local auth = Controls.username.String .. ":" .. Controls.password.String
        local base64_auth = Crypto.Base64Encode(auth)
        request = request .. string.format("Authorization: Basic %s\r\n", base64_auth)
      end
      
      if body then
        request = request .. string.format("Content-Length: %d\r\n", #body)
        request = request .. "Content-Type: application/x-www-form-urlencoded\r\n"
      end
      
      request = request .. "Connection: close\r\n\r\n"
      
      if body then
        request = request .. body
      end
      
      DebugPrint("Tx", "Sending HTTP request:\n" .. request)
      sock:Write(request)
    end
    
    req_socket.Data = function(sock)
      local data = sock:ReadLine(TcpSocket.EOL.Any)
      while data do
        DebugPrint("Rx", "HTTP Data: " .. data)
        req_buffer = req_buffer .. data .. "\n"
        data = sock:ReadLine(TcpSocket.EOL.Any)
      end
    end
    
    req_socket.Closed = function(sock)
      DebugPrint("Function", "HTTP Request Closed callback")
      
      -- Process received data
      if req_buffer ~= "" then
        -- Extract body from HTTP response
        local body_start = req_buffer:find("\n\n")
        if not body_start then
          body_start = req_buffer:find("\r\n\r\n")
        end
        
        if body_start then
          local body = req_buffer:sub(body_start):gsub("^%s+", "")
          if body ~= "" and callback then
            DebugPrint("Rx", "HTTP Body: " .. body)
            callback(body)
          end
        end
      end
    end
    
    req_socket.Error = function(sock, err)
      DebugPrint("Function", string.format("HTTP Request Error: %s", err))
      UpdateStatus("Error", "HTTP Error: " .. err)
    end
    
    req_socket.Timeout = function(sock)
      DebugPrint("Function", "HTTP Request Timeout")
      UpdateStatus("Error", "HTTP request timeout")
    end
    
    DebugPrint("Tx", string.format("Connecting to %s:%d for request", host, port))
    req_socket:Connect(host, port)
  end
  
  local function SendTasmotaCommand(command, callback)
    DebugPrint("Function", "SendTasmotaCommand: " .. command)
    
    if current_protocol == "HTTP" then
      local path = "/cm?cmnd=" .. EncodeURL(command)
      HTTPRequest("GET", path, nil, callback)
      
    elseif current_protocol == "MQTT" then
      local topic = "cmnd/" .. Controls.mqtt_topic.String .. "/" .. command
      PublishMQTT(topic, "", 0, false)
    end
  end
  
  -- ========================================
  -- MQTT Implementation
  -- ========================================
  
  local function EncodeLength(length)
    local encoded = ""
    repeat
      local byte = length % 128
      length = math.floor(length / 128)
      if length > 0 then
        byte = byte + 128
      end
      encoded = encoded .. string.char(byte)
    until length == 0
    return encoded
  end
  
  local function DecodeLength(data, start_pos)
    local multiplier = 1
    local value = 0
    local pos = start_pos
    local byte
    
    repeat
      if pos > #data then
        return nil, pos
      end
      byte = string.byte(data, pos)
      value = value + (byte % 128) * multiplier
      multiplier = multiplier * 128
      pos = pos + 1
    until (byte < 128)
    
    return value, pos
  end
  
  local function EncodeString(str)
    local len = string.len(str)
    return string.char(math.floor(len / 256), len % 256) .. str
  end
  
  local function BytesToHex(str)
    local hex = ""
    for i = 1, #str do
      hex = hex .. string.format("%02X ", string.byte(str, i))
    end
    return hex
  end
  
  local function SendMQTTConnect()
    DebugPrint("Function", "SendMQTTConnect")
    
    local client_id = "qsys_tasmota_" .. tostring(math.random(10000, 99999))
    local variable_header = EncodeString("MQTT") .. string.char(4) -- Protocol name and level
    
    local connect_flags = 0x02 -- Clean session
    local payload = EncodeString(client_id)
    
    -- Add username/password if provided
    if Controls.username.String ~= "" then
      connect_flags = connect_flags + 0x80 -- Username flag
      payload = payload .. EncodeString(Controls.username.String)
    end
    if Controls.password.String ~= "" then
      connect_flags = connect_flags + 0x40 -- Password flag
      payload = payload .. EncodeString(Controls.password.String)
    end
    
    variable_header = variable_header .. string.char(connect_flags)
    variable_header = variable_header .. string.char(0, 60) -- Keep alive 60 seconds
    
    local remaining_length = string.len(variable_header) + string.len(payload)
    local packet = string.char(0x10) .. EncodeLength(remaining_length) .. variable_header .. payload
    
    DebugPrint("Tx", "MQTT CONNECT: " .. BytesToHex(packet))
    mqtt_socket:Write(packet)
  end
  
  local function SendMQTTPingreq()
    DebugPrint("Tx", "MQTT PINGREQ")
    mqtt_socket:Write(string.char(0xC0, 0x00))
  end
  
  local function SubscribeMQTT(topic, qos)
    DebugPrint("Function", string.format("SubscribeMQTT: %s (QoS %d)", topic, qos))
    
    if not mqtt_socket or not mqtt_socket.IsConnected or not is_connected then
      DebugPrint("Function", "Cannot subscribe - not connected")
      return
    end
    
    local variable_header = string.char(math.floor(packet_id / 256), packet_id % 256)
    local payload = EncodeString(topic) .. string.char(qos)
    
    local remaining_length = string.len(variable_header) + string.len(payload)
    local packet = string.char(0x82) .. EncodeLength(remaining_length) .. variable_header .. payload
    
    DebugPrint("Tx", string.format("MQTT SUBSCRIBE [%d]: %s", packet_id, BytesToHex(packet)))
    mqtt_socket:Write(packet)
    
    subscribed_topics[topic] = true
    
    packet_id = packet_id + 1
    if packet_id > 65535 then packet_id = 1 end
  end
  
  function PublishMQTT(topic, payload, qos, retain)
    DebugPrint("Function", string.format("PublishMQTT: %s = %s", topic, payload))
    
    if not mqtt_socket or not mqtt_socket.IsConnected or not is_connected then
      DebugPrint("Function", "Cannot publish - not connected")
      return
    end
    
    local fixed_header_byte = 0x30 -- PUBLISH
    
    if qos == 1 then
      fixed_header_byte = fixed_header_byte + 0x02
    elseif qos == 2 then
      fixed_header_byte = fixed_header_byte + 0x04
    end
    
    if retain then
      fixed_header_byte = fixed_header_byte + 0x01
    end
    
    local variable_header = EncodeString(topic)
    
    if qos > 0 then
      variable_header = variable_header .. string.char(math.floor(packet_id / 256), packet_id % 256)
      packet_id = packet_id + 1
      if packet_id > 65535 then packet_id = 1 end
    end
    
    local remaining_length = string.len(variable_header) + string.len(payload)
    local packet = string.char(fixed_header_byte) .. EncodeLength(remaining_length) .. variable_header .. payload
    
    DebugPrint("Tx", string.format("MQTT PUBLISH: %s", BytesToHex(packet)))
    mqtt_socket:Write(packet)
  end
  
  -- ========================================
  -- Tasmota Response Parser
  -- ========================================
  
  local function ParseTasmotaResponse(topic, payload)
    DebugPrint("Function", "ParseTasmotaResponse")
    
    if not payload or payload == "" then
      DebugPrint("Function", "Empty response payload")
      return
    end
    
    local data = ParseJSON(payload)
    
    if type(data) ~= "table" then
      Controls.command_response.String = payload
      return
    end
    
    -- Parse power states
    local relay_count = Properties["Power Relay Count"].Value
    if relay_count > 0 and Controls.power and Controls.power[1] then
      if data.POWER ~= nil then
        Controls.power[1].Boolean = (data.POWER == "ON")
        Controls.power_status[1].Boolean = (data.POWER == "ON")
      end
      
      for i = 1, relay_count do
        local key = "POWER" .. i
        if data[key] ~= nil and Controls.power[i] then
          Controls.power[i].Boolean = (data[key] == "ON")
          Controls.power_status[i].Boolean = (data[key] == "ON")
        end
      end
    end
    
    -- Parse sensor data
    if data.StatusSNS ~= nil then
      local sensors = data.StatusSNS
      local temp_count = Properties["Temperature Sensor Count"].Value
      local hum_count = Properties["Humidity Sensor Count"].Value
      local press_count = Properties["Pressure Sensor Count"].Value
      
      -- Temperature sensors
      if temp_count > 0 and Controls.temperature and Controls.temperature[1] then
        if sensors.DS18B20 and sensors.DS18B20.Temperature then
          Controls.temperature[1].String = string.format("%.1f C", sensors.DS18B20.Temperature)
        end
        
        if sensors.DHT11 or sensors.DHT22 or sensors.AM2301 then
          local dht = sensors.DHT11 or sensors.DHT22 or sensors.AM2301
          if dht.Temperature then
            Controls.temperature[1].String = string.format("%.1f C", dht.Temperature)
          end
        end
        
        if sensors.BME280 or sensors.BMP280 then
          local bme = sensors.BME280 or sensors.BMP280
          if bme.Temperature then
            Controls.temperature[1].String = string.format("%.1f C", bme.Temperature)
          end
        end
      end
      
      -- Humidity sensors
      if hum_count > 0 and Controls.humidity and Controls.humidity[1] then
        if sensors.DHT11 or sensors.DHT22 or sensors.AM2301 then
          local dht = sensors.DHT11 or sensors.DHT22 or sensors.AM2301
          if dht.Humidity then
            Controls.humidity[1].String = string.format("%.1f %%", dht.Humidity)
          end
        end
        
        if sensors.BME280 then
          if sensors.BME280.Humidity then
            Controls.humidity[1].String = string.format("%.1f %%", sensors.BME280.Humidity)
          end
        end
      end
      
      -- Pressure sensors
      if press_count > 0 and Controls.pressure and Controls.pressure[1] then
        if sensors.BME280 or sensors.BMP280 then
          local bme = sensors.BME280 or sensors.BMP280
          if bme.Pressure then
            Controls.pressure[1].String = string.format("%.1f hPa", bme.Pressure)
          end
        end
      end
      
      -- Power monitoring
      if sensors.ENERGY then
        if sensors.ENERGY.Voltage then
          Controls.voltage.String = string.format("%.1f V", sensors.ENERGY.Voltage)
        end
        if sensors.ENERGY.Current then
          Controls.current.String = string.format("%.3f A", sensors.ENERGY.Current)
        end
        if sensors.ENERGY.Power then
          Controls.power_watts.String = string.format("%.1f W", sensors.ENERGY.Power)
        end
        if sensors.ENERGY.Total then
          Controls.energy_kwh.String = string.format("%.3f kWh", sensors.ENERGY.Total)
        end
      end
    end
    
    -- Parse status information
    if data.StatusNET then
      if data.StatusNET.IPAddress then
        Controls.ip_address.String = data.StatusNET.IPAddress
      end
    end
    
    if data.StatusSTS then
      if data.StatusSTS.Wifi then
        if data.StatusSTS.Wifi.RSSI then
          Controls.wifi_rssi.String = string.format("%d dBm", data.StatusSTS.Wifi.RSSI)
        end
      end
      if data.StatusSTS.Uptime then
        Controls.uptime.String = data.StatusSTS.Uptime
      end
    end
    
    if data.Status then
      local relay_count = Properties["Power Relay Count"].Value
      if data.Status.FriendlyName and relay_count > 0 and Controls.friendly_name then
        if type(data.Status.FriendlyName) == "table" then
          for i, name in ipairs(data.Status.FriendlyName) do
            if i <= relay_count and Controls.friendly_name[i] then
              Controls.friendly_name[i].String = name
            end
          end
        end
      end
      if data.Status.DeviceName then
        Controls.device_name.String = data.Status.DeviceName
      end
    end
    
    if data.StatusFWR then
      if data.StatusFWR.Version then
        Controls.firmware_version.String = data.StatusFWR.Version
      end
    end
    
    if data.StatusMEM then
      if data.StatusMEM.Heap then
        Controls.heap_memory.String = string.format("%d kB", data.StatusMEM.Heap)
      end
    end
    
    -- Dimmer
    if data.Dimmer ~= nil then
      Controls.dimmer.Value = data.Dimmer
    end
    
    -- Color
    if data.Color then
      local color = data.Color
      -- Parse hex color (e.g., "FF00FF")
      if type(color) == "string" and #color >= 6 then
        local r = tonumber(color:sub(1, 2), 16)
        local g = tonumber(color:sub(3, 4), 16)
        local b = tonumber(color:sub(5, 6), 16)
        if r then Controls.color_r.Value = r end
        if g then Controls.color_g.Value = g end
        if b then Controls.color_b.Value = b end
      end
    end
    
    -- Store full response
    Controls.command_response.String = StringifyJSON(data)
  end
  
  local function HandleMQTTPacket(packet_type, flags, data, remaining_length)
    DebugPrint("Rx", string.format("MQTT Packet Type: 0x%02X, Flags: 0x%02X, Length: %d", packet_type, flags, remaining_length))
    
    if packet_type == 2 then -- CONNACK
      if #data >= 2 then
        local return_code = string.byte(data, 2)
        if return_code == 0 then
          DebugPrint("Rx", "MQTT CONNACK: Connection accepted")
          UpdateStatus("Connected", "MQTT connected")
          is_connected = true
          
          -- Subscribe to Tasmota topics
          local base_topic = Controls.mqtt_topic.String
          if base_topic ~= "" then
            SubscribeMQTT("stat/" .. base_topic .. "/#", 0)
            SubscribeMQTT("tele/" .. base_topic .. "/#", 0)
          end
          
          -- Start keep-alive timer
          if keep_alive_timer then
            keep_alive_timer:Stop()
          end
          keep_alive_timer = Timer.New()
          keep_alive_timer.EventHandler = function()
            SendMQTTPingreq()
          end
          keep_alive_timer:Start(30)
        else
          DebugPrint("Rx", string.format("MQTT CONNACK: Connection refused (code %d)", return_code))
          UpdateStatus("Error", "MQTT connection refused")
        end
      end
      
    elseif packet_type == 3 then -- PUBLISH
      local qos = math.floor((flags % 8) / 2)
      local retain = (flags % 2) == 1
      
      -- Parse topic length
      local topic_len = string.byte(data, 1) * 256 + string.byte(data, 2)
      local topic = string.sub(data, 3, 2 + topic_len)
      
      local payload_start = 3 + topic_len
      
      -- Skip packet ID for QoS > 0
      if qos > 0 then
        payload_start = payload_start + 2
      end
      
      local payload = string.sub(data, payload_start)
      
      DebugPrint("Rx", string.format("MQTT PUBLISH: Topic=%s, Payload=%s, QoS=%d, Retain=%s", 
        topic, payload, qos, tostring(retain)))
      
      -- Parse Tasmota responses
      ParseTasmotaResponse(topic, payload)
      
    elseif packet_type == 9 then -- SUBACK
      DebugPrint("Rx", "MQTT SUBACK received")
      
    elseif packet_type == 13 then -- PINGRESP
      DebugPrint("Rx", "MQTT PINGRESP received")
    end
  end
  
  -- ========================================
  -- Connection Management
  -- ========================================
  
  local function ConnectHTTP()
    DebugPrint("Function", "ConnectHTTP")
    
    local host = Controls.host.String
    local port = tonumber(Controls.port.String) or 80
    
    if host == "" then
      UpdateStatus("Error", "No host specified")
      return
    end
    
    current_protocol = "HTTP"
    Controls.protocol.String = "HTTP"
    UpdateStatus("Connecting", "Starting HTTP polling to " .. host .. ":" .. port)
    
    -- Start timer-based polling
    StartHTTPPolling()
  end
  
  local function ConnectMQTT()
    DebugPrint("Function", "ConnectMQTT")
    current_protocol = "MQTT"
    Controls.protocol.String = "MQTT"
    
    if mqtt_socket then
      mqtt_socket:Disconnect()
    end
    
    mqtt_socket = TcpSocket.New()
    mqtt_socket.ReadTimeout = 0
    mqtt_socket.WriteTimeout = Properties["Connection Timeout"].Value
    
    mqtt_socket.Connected = function(sock)
      DebugPrint("Function", "MQTT socket connected")
      UpdateStatus("Connecting", "MQTT handshake...")
      SendMQTTConnect()
    end
    
    mqtt_socket.Reconnect = function(sock)
      DebugPrint("Function", "MQTT reconnect")
      UpdateStatus("Connecting", "MQTT reconnecting...")
    end
    
    mqtt_socket.Data = function(sock)
      local data = sock:Read(sock.BufferLength)
      if not data or #data == 0 then return end
      
      DebugPrint("Rx", "MQTT Data: " .. BytesToHex(data))
      
      local pos = 1
      while pos <= #data do
        -- Parse fixed header
        local header_byte = string.byte(data, pos)
        local packet_type = math.floor(header_byte / 16)
        local flags = header_byte % 16
        pos = pos + 1
        
        -- Parse remaining length
        local remaining_length, new_pos = DecodeLength(data, pos)
        if not remaining_length then break end
        pos = new_pos
        
        -- Extract packet data
        if pos + remaining_length - 1 <= #data then
          local packet_data = string.sub(data, pos, pos + remaining_length - 1)
          pos = pos + remaining_length
          
          HandleMQTTPacket(packet_type, flags, packet_data, remaining_length)
        else
          break
        end
      end
    end
    
    mqtt_socket.Closed = function(sock)
      DebugPrint("Function", "MQTT socket closed")
      UpdateStatus("Disconnected", "MQTT connection closed")
      is_connected = false
    end
    
    mqtt_socket.Error = function(sock, err)
      DebugPrint("Function", "MQTT error: " .. err)
      UpdateStatus("Error", "MQTT error: " .. err)
    end
    
    mqtt_socket.Timeout = function(sock)
      DebugPrint("Function", "MQTT timeout")
      UpdateStatus("Error", "MQTT connection timeout")
    end
    
    local port = tonumber(Controls.port.String) or 1883
    DebugPrint("Tx", string.format("Connecting to MQTT broker %s:%d", Controls.host.String, port))
    mqtt_socket:Connect(Controls.host.String, port)
  end
  
  local function Disconnect()
    DebugPrint("Function", "Disconnect")
    
    is_connected = false
    
    -- Stop HTTP polling
    if current_protocol == "HTTP" then
      StopHTTPPolling()
    end
    
    -- Stop old poll_timer if it exists
    if poll_timer then
      poll_timer:Stop()
      poll_timer = nil
    end
    
    if keep_alive_timer then
      keep_alive_timer:Stop()
      keep_alive_timer = nil
    end
    
    if http_socket and http_socket.IsConnected then
      http_socket:Disconnect()
    end
    
    if mqtt_socket and mqtt_socket.IsConnected then
      mqtt_socket:Disconnect()
    end
    
    UpdateStatus("Disconnected", "Disconnected")
  end
  
  -- ========================================
  -- Control Event Handlers
  -- ========================================
  
  -- Connection Controls
  Controls.protocol_http.EventHandler = function(ctl)
    if ctl.Boolean then
      current_protocol = "HTTP"
      Controls.protocol.String = "HTTP"
      print("[Tasmota] Protocol selected: HTTP")
      -- DO NOT connect here - user must press Connect button
    end
  end
  
  Controls.protocol_mqtt.EventHandler = function(ctl)
    if ctl.Boolean then
      current_protocol = "MQTT"
      Controls.protocol.String = "MQTT"
      print("[Tasmota] Protocol selected: MQTT")
      -- DO NOT connect here - user must press Connect button
    end
  end
  
  Controls.connect.EventHandler = function(ctl)
    if ctl.Boolean then
      -- User pressed Connect - establish connection using selected protocol
      print("[Tasmota] Connecting using protocol: " .. current_protocol)
      Controls.connection_state.String = "Connecting..."
      Controls.connection_status.Value = 1  -- Initializing
      
      -- Validate MQTT broker address
      if current_protocol == "MQTT" then
        if Controls.host.String == "" then
          print("[Tasmota] ERROR: MQTT broker address must be set")
          Controls.connection_state.String = "Error: MQTT broker address required"
          Controls.connection_status.Value = 5  -- Fault
          Controls.connect.Boolean = false
          return
        end
      end
      
      -- Disconnect any other active protocol first
      Disconnect()
      
      -- Connect with selected protocol
      if current_protocol == "HTTP" then
        ConnectHTTP()
      elseif current_protocol == "MQTT" then
        ConnectMQTT()
      end
    else
      -- User pressed Disconnect
      print("[Tasmota] Disconnecting...")
      Disconnect()
      Controls.connection_state.String = "Disconnected"
      Controls.connection_status.Value = 2  -- Compromised/Disconnected
    end
  end
  
  Controls.poll_interval.EventHandler = function(ctl)
    DebugPrint("Function", string.format("Poll interval changed to %d seconds", ctl.Value))
    
    -- If HTTP polling is active, restart with new interval
    if is_polling and current_protocol == "HTTP" then
      DebugPrint("Function", "Restarting HTTP polling with new interval")
      StartHTTPPolling()
    end
    
    -- Legacy support for old poll_timer
    if poll_timer and poll_timer.IsRunning then
      poll_timer:Stop()
      poll_timer:Start(ctl.Value)
    end
  end
  
  -- Power Controls
  for i = 1, Properties["Power Relay Count"].Value do
    Controls.power[i].EventHandler = function(ctl)
      local cmd = string.format("Power%d %s", i, ctl.Boolean and "ON" or "OFF")
      SendTasmotaCommand(cmd, function(response)
        ParseTasmotaResponse("power", response)
      end)
    end
    
    Controls.pulse_time[i].EventHandler = function(ctl)
      if ctl.String ~= "" then
        local cmd = string.format("PulseTime%d %s", i, ctl.String)
        SendTasmotaCommand(cmd, function(response)
          ParseTasmotaResponse("pulsetime", response)
        end)
      end
    end
    
    Controls.power_on_state[i].EventHandler = function(ctl)
      if ctl.String ~= "" then
        local cmd = string.format("PowerOnState%d %s", i, ctl.String)
        SendTasmotaCommand(cmd, function(response)
          ParseTasmotaResponse("poweronstate", response)
        end)
      end
    end
  end
  
  -- Light Controls
  Controls.dimmer.EventHandler = function(ctl)
    local cmd = string.format("Dimmer %d", ctl.Value)
    SendTasmotaCommand(cmd, function(response)
      ParseTasmotaResponse("dimmer", response)
    end)
  end
  
  Controls.color_r.EventHandler = function(ctl)
    local r = Controls.color_r.Value
    local g = Controls.color_g.Value
    local b = Controls.color_b.Value
    local cmd = string.format("Color %02X%02X%02X", r, g, b)
    SendTasmotaCommand(cmd, function(response)
      ParseTasmotaResponse("color", response)
    end)
  end
  
  Controls.color_g.EventHandler = Controls.color_r.EventHandler
  Controls.color_b.EventHandler = Controls.color_r.EventHandler
  
  Controls.color_w.EventHandler = function(ctl)
    local cmd = string.format("White %d", ctl.Value)
    SendTasmotaCommand(cmd, function(response)
      ParseTasmotaResponse("white", response)
    end)
  end
  
  Controls.color_temp.EventHandler = function(ctl)
    local cmd = string.format("CT %d", ctl.Value)
    SendTasmotaCommand(cmd, function(response)
      ParseTasmotaResponse("ct", response)
    end)
  end
  
  Controls.hsb_h.EventHandler = function(ctl)
    local h = Controls.hsb_h.Value
    local s = Controls.hsb_s.Value
    local b = Controls.hsb_b.Value
    local cmd = string.format("HsbColor %d,%d,%d", h, s, b)
    SendTasmotaCommand(cmd, function(response)
      ParseTasmotaResponse("hsb", response)
    end)
  end
  
  Controls.hsb_s.EventHandler = Controls.hsb_h.EventHandler
  Controls.hsb_b.EventHandler = Controls.hsb_h.EventHandler
  
  Controls.scheme.EventHandler = function(ctl)
    if ctl.String ~= "" then
      local cmd = string.format("Scheme %s", ctl.String)
      SendTasmotaCommand(cmd, function(response)
        ParseTasmotaResponse("scheme", response)
      end)
    end
  end
  
  Controls.fade_speed.EventHandler = function(ctl)
    local cmd = string.format("Speed %d", ctl.Value)
    SendTasmotaCommand(cmd, function(response)
      ParseTasmotaResponse("speed", response)
    end)
  end
  
  -- GPIO Controls
  for i = 1, Properties["GPIO Output Count"].Value do
    Controls.gpio_out[i].EventHandler = function(ctl)
      -- Note: GPIO pin numbers need to be configured
      -- This is a placeholder - actual implementation would need GPIO mapping
      local cmd = string.format("Gpio%d %d", i, ctl.Boolean and 1 or 0)
      SendTasmotaCommand(cmd, function(response)
        ParseTasmotaResponse("gpio", response)
      end)
    end
  end
  
  for i = 1, Properties["PWM Count"].Value do
    Controls.pwm[i].EventHandler = function(ctl)
      local cmd = string.format("Pwm%d %d", i, ctl.Value)
      SendTasmotaCommand(cmd, function(response)
        ParseTasmotaResponse("pwm", response)
      end)
    end
  end
  
  -- Custom Command
  Controls.send_command.EventHandler = function(ctl)
    local cmd = Controls.custom_command.String
    if cmd ~= "" then
      SendTasmotaCommand(cmd, function(response)
        ParseTasmotaResponse("custom", response)
      end)
    end
  end
  
  -- ========================================
  -- Initialization
  -- ========================================
  
  -- Set default values
  current_protocol = Properties["Default Protocol"].Value
  Controls.protocol.String = current_protocol
  Controls.poll_interval.Value = 5
  
  -- Set default port based on protocol
  if Controls.port.String == "" then
    if Properties["Default Protocol"].Value == "MQTT" then
      Controls.port.String = "1883"
    else
      Controls.port.String = "80"
    end
  end
  
  UpdateStatus("Disconnected", "Select protocol above, then press Connect")
  
  -- Auto-connect if enabled
  if Properties["Auto Connect"].Value then
    Timer.CallAfter(function()
      Controls.connect.Boolean = true
    end, 2)
  end
  
  DebugPrint("Function", "Tasmota ESP32 Interface Plugin Initialized")
end

